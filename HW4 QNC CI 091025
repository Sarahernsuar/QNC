#Method1 Multiples of SEM
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
import math

# Reproducibility
np.random.seed(2025)

# Population parameters
mu_true = 10.0
sigma_true = 2.0
ns = [5, 10, 20, 40, 80, 160, 1000]
alpha = 0.05

# Critical z-value for 95% CI
z_crit = stats.norm.ppf(1 - alpha/2)

results = []  # list to hold results

for n in ns:
    # Draw n samples from N(10, 2)
    sample = np.random.normal(loc=mu_true, scale=sigma_true, size=n)
    xbar = sample.mean()  # sample mean
    
    # Standard error using known σ
    se_pop = sigma_true / math.sqrt(n)
    
    # CI bounds
    lower = xbar - z_crit * se_pop
    upper = xbar + z_crit * se_pop
    
    # Half-width check in terms of SE
    half_width = (upper - lower) / 2
    half_width_in_se = half_width / se_pop   # <-- correctly defined
    
    # Store results as a tuple
    results.append((n, xbar, se_pop, z_crit, half_width, half_width_in_se, lower, upper))

# Print results in a neat format
print(f"{'n':>6} {'mean':>8} {'SE':>8} {'k':>6} {'half_w':>10} {'half_w/SE':>10} {'CI_lower':>10} {'CI_upper':>10}")
for r in results:
    print(f"{r[0]:6d} {r[1]:8.4f} {r[2]:8.4f} {r[3]:6.2f} {r[4]:10.4f} {r[5]:10.2f} {r[6]:10.4f} {r[7]:10.4f}")

# Plot the intervals
plt.figure(figsize=(9,5))
y = np.arange(len(ns))
for i, r in enumerate(results):
    mean = r[1]
    lower = r[6]
    upper = r[7]
    plt.errorbar(mean, y[i],
                 xerr=[[mean-lower],[upper-mean]],
                 fmt='o', capsize=4)
plt.axvline(mu_true, linestyle='--', linewidth=1)
plt.yticks(y, [str(n) for n in ns])
plt.gca().invert_yaxis()
plt.xlabel("Value")
plt.ylabel("Sample size n")
plt.title("95% CI (mean ± 1.96·SE) with known σ=2")
plt.grid(axis='x', linestyle=':', linewidth=0.6)
plt.tight_layout()
plt.show()
#Mehtod2 Student's t & Z-score  
import numpy as np
from scipy import stats
import matplotlib.pyplot as plt

# Parameters
population_mean = 10
population_std = 2
sample_sizes = [5, 10, 20, 40, 80, 160, 1000]
confidence = 0.95

# Store results
results = []

plt.figure(figsize=(12, 8))

for i, n in enumerate(sample_sizes):
    # Simulate data
    data = np.random.normal(loc=population_mean, scale=population_std, size=n)
    
    # Sample mean and SD
    sample_mean = np.mean(data)
    sample_std = np.std(data, ddof=1)
    
    # Z-scores
    z_scores = (data - sample_mean) / sample_std
    
    # Confidence interval using Z-score
    z_critical = stats.norm.ppf((1 + confidence) / 2)
    margin_error = z_critical * (sample_std / np.sqrt(n))
    ci_z = (sample_mean - margin_error, sample_mean + margin_error)
    
    results.append({
        "n": n,
        "mean": sample_mean,
        "CI": ci_z,
        "Z-scores": z_scores
    })
    
    # Plot Z-scores
    plt.scatter([i+1]*n, z_scores, alpha=0.6, label=f'n={n}' if i==0 else "")
    
    # Plot CI as horizontal line at sample mean
    plt.hlines(y=0, xmin=i+0.8, xmax=i+1.2, colors='red', linewidth=2)

# Formatting the plot
plt.xticks(range(1, len(sample_sizes)+1), sample_sizes)
plt.axhline(0, color='black', linestyle='--')
plt.title('Z-scores for different sample sizes')
plt.xlabel('Sample size (n)')
plt.ylabel('Z-score')
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()
#Methdod3 Bootstrap CI
import numpy as np
import matplotlib.pyplot as plt

# Parameters
population_mean = 10
population_std = 2
sample_sizes = [5, 10, 20, 40, 80, 160, 1000]
confidence = 0.95
n_bootstrap = 10000  # number of bootstrap samples

# Store results
bootstrap_results = []

plt.figure(figsize=(12, 8))

for i, n in enumerate(sample_sizes):
    # Simulate data
    data = np.random.normal(loc=population_mean, scale=population_std, size=n)
    
    # Bootstrap resampling
    bootstrap_means = []
    for _ in range(n_bootstrap):
        bs_sample = np.random.choice(data, size=n, replace=True)
        bootstrap_means.append(np.mean(bs_sample))
    bootstrap_means = np.array(bootstrap_means)
    
    # 95% confidence interval using percentiles
    lower = np.percentile(bootstrap_means, (1 - confidence)/2 * 100)
    upper = np.percentile(bootstrap_means, (1 + confidence)/2 * 100)
    
    bootstrap_results.append({
        "n": n,
        "sample_mean": np.mean(data),
        "CI_lower": lower,
        "CI_upper": upper
    })
    
    # Plot bootstrap distribution as scatter
    plt.scatter([i+1]*n_bootstrap, bootstrap_means, alpha=0.05, color='blue')
    
    # Plot CI as vertical line
    plt.vlines(i+1, ymin=lower, ymax=upper, color='red', linewidth=3)

# Formatting the plot
plt.xticks(range(1, len(sample_sizes)+1), sample_sizes)
plt.xlabel('Sample size (n)')
plt.ylabel('Bootstrap sample means')
plt.title('Bootstrap Confidence Intervals for Different Sample Sizes')
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()
#Method4 Bayesian CI
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm

# Parameters
population_mean = 10
population_std = 2
sample_sizes = [5, 10, 20, 40, 80, 160, 1000]
confidence = 0.95
n_posterior_samples = 10000  # number of posterior samples

# Store results
bayes_results = []

plt.figure(figsize=(12, 8))

for i, n in enumerate(sample_sizes):
    # Simulate data
    data = np.random.normal(loc=population_mean, scale=population_std, size=n)
    
    # Sample mean and standard deviation
    sample_mean = np.mean(data)
    sample_std = np.std(data, ddof=1)
    
    # Posterior distribution for the mean (assume Gaussian likelihood)
    # Using sample_std as an estimate of sigma
    posterior_std = sample_std / np.sqrt(n)
    posterior_samples = np.random.normal(loc=sample_mean, scale=posterior_std, size=n_posterior_samples)
    
    # 95% credible interval
    lower = np.percentile(posterior_samples, (1-confidence)/2 * 100)
    upper = np.percentile(posterior_samples, (1+confidence)/2 * 100)
    
    bayes_results.append({
        "n": n,
        "mean": sample_mean,
        "CI_lower": lower,
        "CI_upper": upper
    })
    
    # Plot posterior samples
    plt.scatter([i+1]*n_posterior_samples, posterior_samples, alpha=0.05, color='green')
    
    # Plot credible interval as vertical line
    plt.vlines(i+1, ymin=lower, ymax=upper, color='red', linewidth=3)

# Formatting the plot
plt.xticks(range(1, len(sample_sizes)+1), sample_sizes)
plt.xlabel('Sample size (n)')
plt.ylabel('Posterior samples of mean')
plt.title('Bayesian 95% Credible Intervals for Different Sample Sizes')
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()
