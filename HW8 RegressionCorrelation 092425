import math
import numpy as np
import matplotlib.pyplot as plt

#Data
X = np.array([10.4, 10.8, 11.1, 10.2, 10.3, 10.2, 10.7, 10.5, 10.8, 11.2, 10.6, 11.4], dtype=float) #Wing Lenght
Y = np.array([ 7.4,  7.6,  7.9,  7.2,  7.4,  7.1,  7.4,  7.2,  7.8,  7.7,  7.8,  8.3], dtype=float) #Tail Lenght
n = len(X)

#Scatter Plot Determine How the Data Looks 
#Fisher Transformation
def fisher_z(r):
    return 0.5 * math.log((1 + r) / (1 - r))

#Convert back to r
def fisher_r(z):
    ez2 = math.exp(2 * z)
    return (ez2 - 1) / (ez2 + 1)

def t_test_p_two_tailed(t, df):
    try:
        # Two-tailed p-value for a t-statistic 
        from scipy.stats import t as student_t
        return 2 * student_t.sf(abs(t), df)
    except Exception:
        try:
            import mpmath as mp
            v = df
            pdf_t = lambda x: mp.gamma((v+1)/2) / (mp.sqrt(v*mp.pi) * mp.gamma(v/2)) * (1 + x**2 / v) ** (-(v+1)/2)
            cdf = 0.5 + mp.quad(pdf_t, [0, abs(t)])  # symmetry
            return float(2 * (1 - cdf))
        except Exception:
            return float('nan')

#p is the true population
def power_for_rho(rho, n, alpha=0.05):
    if n <= 3:
        return 0.0
    zcrit = 1.96 if abs(alpha - 0.05) < 1e-12 else abs(np.quantile(np.random.randn(10_0000), 1 - alpha/2))  # keep 1.96 for alpha=0.05
    mu = fisher_z(rho) * math.sqrt(n - 3)
    from math import erf, sqrt
    Phi = lambda x: 0.5 * (1 + erf(x / math.sqrt(2)))
    # P(|Z'| > zcrit) = P(Z' < -zcrit) + P(Z' > zcrit)
    return Phi(-zcrit - mu) + (1 - Phi(zcrit - mu))

def sample_size_for_power(rho, target_power=0.8, alpha=0.05, n_min=4, n_max=2000):
    for N in range(n_min, n_max + 1):
        if power_for_rho(rho, N, alpha) >= target_power:
            return N
    return None

#Scatter Plot
plt.figure()
plt.scatter(X, Y)
plt.xlabel("Wing length (cm) [X]")
plt.ylabel("Tail length (cm) [Y]")
plt.title("Scatter plot: Wing length vs Tail length")
plt.tight_layout()
plt.show()

#Correlations
xbar = float(np.mean(X)); sx = float(np.std(X, ddof=1))
ybar = float(np.mean(Y)); sy = float(np.std(Y, ddof=1))
cov_xy = float(np.sum((X - xbar) * (Y - ybar)) / (n - 1))
r_manual = cov_xy / (sx * sy)

r_np = float(np.corrcoef(X, Y)[0, 1])
r_yx = float(np.corrcoef(Y, X)[0, 1])  # symmetry check

#95% CI via Fisher Z 
SE_z = 1 / math.sqrt(n - 3)
z = fisher_z(r_np)
zcrit = 1.96  # for 95%
z_lo, z_hi = z - zcrit * SE_z, z + zcrit * SE_z
r_lo, r_hi = fisher_r(z_lo), fisher_r(z_hi)

#Hypothesis Testing H0: rho = 0 (two-tailed)
df_t = n - 2
t_stat = r_np * math.sqrt(df_t) / math.sqrt(1 - r_np * r_np)
p_two_tailed = t_test_p_two_tailed(t_stat, df_t)

# Two-tailed p-value for a normal (Z) statistic
def norm_p_two_tailed(z):
    from scipy.stats import norm
    return 2 * norm.sf(abs(z))

#Hypothesis test: H0: rho = 0.75 (two-tailed) using Fisher z
rho0 = 0.75
Z_stat = (fisher_z(r_np) - fisher_z(rho0)) / SE_z
p_r_eq_rho0 = norm_p_two_tailed(Z_stat)

#Power and Sample Size for rho = 0.5 (two-tailed alpha=0.05)
rho_target = 0.5
power_at_n = power_for_rho(rho_target, n, alpha=0.05)
n_for_80 = sample_size_for_power(rho_target, target_power=0.8, alpha=0.05)

#Print
def fmt(x, d=6):
    try:
        return f"{float(x):.{d}f}"
    except Exception:
        return str(x)

print("\n=== Correlation & Power Analysis ===")
print(f"n = {n}")
print(f"xbar, sx = {fmt(xbar,4)}, {fmt(sx,4)}")
print(f"ybar, sy = {fmt(ybar,4)}, {fmt(sy,4)}")
print(f"cov_xy (n-1 denom) = {fmt(cov_xy,6)}")
print(f"r (manual)   = {fmt(r_manual,6)}")
print(f"r (NumPy)    = {fmt(r_np,6)}")
print(f"r (Y,X)      = {fmt(r_yx,6)}  # symmetry check")
print(f"95% CI for r (Fisher z) = [{fmt(r_lo,6)}, {fmt(r_hi,6)}]")
print(f"t-stat (H0: rho=0), df = {fmt(t_stat,6)}, {df_t}")
print(f"p-value (two-tailed, t) = {fmt(p_two_tailed,6)}")
print(f"Test H0: rho=0.75 -> Z = {fmt(Z_stat,6)}, p(two-tailed) = {fmt(p_r_eq_rho0,6)}")
print(f"Power at n={n} for rho=0.5 (alpha=0.05) = {fmt(power_at_n,6)}")
print(f"n for 80% power (rho=0.5, alpha=0.05)   = {n_for_80}")