"""
Figures:
  Figure A – Simulated RTs, reciprobit (raw axes), reciprobit (relabeled axes)
  Figure B – Analytic reciprobit lines showing parameter effects:
             (top) vary mu_R (shift)
             (bottom) vary delta_S (swivel)
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import norm

# ----------------------------
# Core LATER relationships
# ----------------------------

def simulate_rts(muR=4.0, stdR=1.0, deltaS=1.2, N=10_000, rng_seed=7):
    """Simulate RTs from the LATER model."""
    rng = np.random.default_rng(rng_seed)
    # draw decision rates; avoid non-positive tiny rates for numerical stability
    r = rng.normal(muR, stdR, size=N)
    r = np.clip(r, 1e-3, None)
    RT = deltaS / r
    return RT

def reciprobit_empirical(RT):
    """Return x (=-1/RT) sorted and y (=probit of empirical cumulative prob)."""
    RT_sorted = np.sort(RT)
    N = len(RT_sorted)
    x = -1.0 / RT_sorted
    cumprob = np.arange(1, N + 1, dtype=float) / float(N)
    y = norm.ppf(cumprob)  # probit (z-score)
    return x, y

def set_reciprobit_tick_labels(ax, x_ms_labels=(200, 500, 1000, 2000),
                               y_pct_labels=(0.1, 10, 50, 90, 99.9)):

    
    x_ticks = -1000.0 / np.array(x_ms_labels, dtype=float)  # -1/RT with RT in ms
    y_ticks = norm.ppf(np.array(y_pct_labels, dtype=float) / 100.0)

    ax.set_xticks(x_ticks)
    ax.set_xticklabels([str(ms) for ms in x_ms_labels])
    ax.set_yticks(y_ticks)
    ax.set_yticklabels([str(p) for p in y_pct_labels])

def figure_A_simulation(muR=4.0, stdR=1.0, deltaS=1.2, N=10_000):
   
    RT = simulate_rts(muR, stdR, deltaS, N=N)
    x_vals, y_vals = reciprobit_empirical(RT)

    fig, axs = plt.subplots(3, 1, figsize=(8, 10))
    fig.canvas.manager.set_window_title("Figure A – Simulation & Reciprocity")

    # --- (top) RT histogram ---
    axs[0].hist(RT, bins=np.arange(0, 2.01, 0.01), edgecolor='black')
    axs[0].set_xlim(0, 2.0)
    axs[0].set_xlabel("RT (sec)")
    axs[0].set_ylabel("Count")
    axs[0].set_title("Figure A1 – Simulated RT distribution")

    # --- common axes limits for reciprobit panels ---
    axs[1].plot(x_vals, y_vals, 'k.', ms=2)
    axs[1].set_xlabel("-1 / RT (1/s)")
    axs[1].set_ylabel("z score")
    axs[1].set_title("Figure A2 – Reciprocity (raw axes)")
    axs[1].grid(True, linestyle='--', alpha=0.3)

    # snapshot limits to reuse
    xlm = axs[1].get_xlim()
    ylm = axs[1].get_ylim()

    # Overlay analytic geometry on panel 2
    x_intercept = -muR / deltaS                # where probit (y)=0
    axs[1].plot([xlm[0], x_intercept], [0, 0], 'r-')             # horizontal to intercept
    axs[1].plot([x_intercept, x_intercept], [ylm[0], 0], 'r-')   # vertical up to (x_int, 0)
    axs[1].plot(x_intercept, 0, 'ro', label="x-intercept = -muR/deltaS")

    # 1 SD vector (rise 1 in z per +1/deltaS in x)
    axs[1].plot([x_intercept, x_intercept + 1/deltaS],
                [0, 1], 'r-', lw=2, label="1 SD in x ( = 1/deltaS )")
    # Analytic line y = deltaS * x + muR
    xx_demo = np.linspace(xlm[0], xlm[1], 200)
    axs[1].plot(xx_demo, deltaS * xx_demo + muR, 'g-', label="y = deltaS * x + muR")
    axs[1].legend(loc='lower right', fontsize=8)

    # --- (bottom) reciprobit with axis relabels in ms / % ---
    axs[2].plot(x_vals, y_vals, 'k.', ms=2)
    axs[2].set_xlim(xlm); axs[2].set_ylim(ylm)
    set_reciprobit_tick_labels(axs[2],
                               x_ms_labels=(200, 500, 1000, 2000),
                               y_pct_labels=(0.1, 10, 50, 90, 99.9))
    axs[2].set_xlabel("RT (ms)  [axis is -1/RT; labels show RT]")
    axs[2].set_ylabel("Cum prob (%)  [axis is probit(z)]")
    axs[2].set_title("Figure A3 – Reciprocity (relabeled axes)")
    axs[2].grid(True, linestyle='--', alpha=0.3)

    # Overlay same analytic geometry on relabeled panel
    axs[2].plot([xlm[0], x_intercept], [0, 0], 'r-')
    axs[2].plot([x_intercept, x_intercept], [ylm[0], 0], 'r-')
    axs[2].plot(x_intercept, 0, 'ro')
    axs[2].plot([x_intercept, x_intercept + 1/deltaS], [0, 1], 'r-', lw=2)
    axs[2].plot(xx_demo, deltaS * xx_demo + muR, 'g-')

    fig.tight_layout()
    return fig

def figure_B_parameter_variation(muR_base=4.0, deltaS_base=1.2):
    
    fig, axs = plt.subplots(2, 1, figsize=(8, 8))
    fig.canvas.manager.set_window_title("Figure B – Parameter dependence (analytic)")

    # x-range in reciprobit space (use RT between 0.2s and 4s to mimic tutorial range)
    xRT = np.array([0.2, 4.0])          # seconds
    reci_x = -1.0 / xRT                 # -1/RT
    xs = np.linspace(reci_x.min(), reci_x.max(), 100)

    # --- Top: vary muR (shift), fixed deltaS ---
    axs[0].set_title("Figure B1 – Vary muR (shift), fixed deltaS")
    for mu in range(1, 9):  # 1:8
        ys = deltaS_base * xs + mu
        axs[0].plot(xs, ys, 'k-', lw=1)
    axs[0].grid(True, linestyle='--', alpha=0.3)
    set_reciprobit_tick_labels(axs[0],
                               x_ms_labels=(200, 500, 1000, 2000),
                               y_pct_labels=(0.001, 0.1, 10, 50, 90, 99.9, 99.999))
    axs[0].set_xlabel("RT (ms)  [axis is -1/RT; labels show RT]")
    axs[0].set_ylabel("Cum prob (%)  [axis is probit(z)]")

    # --- Bottom: vary deltaS (swivel), fixed muR ---
    axs[1].set_title("Figure B2 – Vary deltaS (swivel), fixed muR")
    deltaSs = np.arange(0.5, 2.0 + 1e-9, 0.1)
    for dS in deltaSs:
        ys = dS * xs + muR_base
        axs[1].plot(xs, ys, 'k-', lw=1)
    axs[1].grid(True, linestyle='--', alpha=0.3)
    set_reciprobit_tick_labels(axs[1],
                               x_ms_labels=(200, 500, 1000, 2000),
                               y_pct_labels=(0.001, 0.1, 10, 50, 90, 99.9, 99.999))
    axs[1].set_xlabel("RT (ms)  [axis is -1/RT; labels show RT]")
    axs[1].set_ylabel("Cum prob (%)  [axis is probit(z)]")

    fig.tight_layout()
    return fig

def main():
    # Default parameters align with the MATLAB tutorial
    muR = 4.0
    stdR = 1.0
    deltaS = 1.2

    figure_A_simulation(muR=muR, stdR=stdR, deltaS=deltaS, N=10_000)
    figure_B_parameter_variation(muR_base=muR, deltaS_base=deltaS)

    plt.show()

if __name__ == "__main__":
    main()